# -*- coding: utf-8 -*-
"""samplingAlgo.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1lsRyuy333fIBGhK9BxdHV_hOegBy2SUt
"""

import spacy
import math
import numpy as np
import json
import sys
import math
import random


def minimum(x1, x2):
  if x1>x2:
    return x2
  else:
    return x1

def difficultyScore(s1):
  if s1[-1] == ".":
    s1 = s1[:-1]
# remove dot in the end if it exists

  adjectiveCount = 0
  nounCount = 0 
  verbCount = 0
  notVan =0

  for word in s1.split():
    nlp = spacy.load("en_core_web_sm")
    doc = nlp(word)
    rp = doc[0].pos_ #resultant pos
    # print(word,  rp)
    if(rp == "NOUN" or rp == "PROPN"):
      nounCount=nounCount+1
    elif(rp == "VERB"):
      verbCount= verbCount+1
    elif(rp =="ADJ"):
      adjectiveCount = adjectiveCount + 1
    else:
      notVan = notVan + 1
      #print("Not a noun, adjective or verb \n")


  # print("adjective count:", adjectiveCount);
  # print("verb count:", verbCount);
  # print("noun count:", nounCount);

  noWords = adjectiveCount + verbCount + nounCount + notVan

  z = 1/(1 + np.exp(noWords*-1)) #sigmoid of noWords
  lengthContribution = math.log(z) if z !=0 else 0
  adjProb = math.log(adjectiveCount/noWords) if adjectiveCount != 0 else 0
  verbProb = math.log(verbCount/noWords) if verbCount != 0 else 0
  nounProb = math.log(nounCount/noWords) if nounCount != 0 else 0

  difficultyScore = -1* (lengthContribution + adjProb + verbProb + nounProb)
  # print(adjProb, verbProb, nounProb, lengthContribution, difficultyScore )
  return difficultyScore;


def sampleQuestions(crudeQuestionsJSON, classChoice, subjectChoice, chapterChoice, noQs, percentHard, percentMed, percentEasy):
    data = {}

    # Opening JSON file
    with open(crudeQuestionsJSON) as json_file:
        data = json.load(json_file)


    #split here based on class, subject and chapter
    filteredQs = []

    for item in data:
      if(item["Class"]==classChoice and item["Subject"]==subjectChoice and item["Chapter"] == chapterChoice):
        filteredQs.append(item)
  
    nlp = spacy.load("en_core_web_sm")

    min = sys.maxsize
    max = -100000

    for item in filteredQs:
      ds = difficultyScore(item['Statement'])
      item["difficultyScore"] = ds
      if min>ds:
        min=ds
      if max<ds:
        max=ds

    middleTop = min + (max - min + 1) /2 + (max- min + 1) /4
    middleBottom = min + (max - min + 1) /2 - (max- min + 1) /4

    hardBin = []
    easyBin = []
    medBin = []

    for item in filteredQs:
      ds = item["difficultyScore"]
      #print(item["Statement"])
      cutItem = {}
      cutItem["trueStmt"] = item["Statement"]
      cutItem["falseStmt"] = random.choice(item["Generated False Question"])

      if(ds>middleTop and ds<=max):
        item["difficulty"]="hard"
        cutItem["difficulty"]="hard"
        hardBin.append(cutItem)

      elif(ds>middleBottom and ds <=middleTop):
        item["difficulty"]="medium"
        cutItem["difficulty"]="medium"
        medBin.append(cutItem)

      else:
        item["difficulty"]="easy"
        cutItem["difficulty"]="easy"
        easyBin.append(cutItem)

    """
    #test
    print("easyBin" + str(easyBin))
    print("medBin" + str(medBin))
    print("hardBin" + str(hardBin))
    print(max, middleTop, middleBottom, min)
    print("-----------------------------------------")
    print("length of hardbin - " + str(len(hardBin)))
    print("length of medbin - " + str(len(medBin)))
    print("length of easybin - " + str(len(easyBin)))
    """

    finalQSet = []

    noHard = int(percentHard*noQs)
    noEasy = int(percentEasy*noQs)
    noMed = int(percentMed*noQs)

    #populate finalQSet

    count = 0
    while count in range(minimum(noHard, len(hardBin))):
        finalQSet.append(hardBin[count])
        count += 1

    count = 0
    while count in range(minimum(noMed, len(medBin))):
        #print(count)
        finalQSet.append(medBin[count])
        count += 1

    count = 0
    while count in range(minimum(noEasy, len(easyBin))):
        finalQSet.append(easyBin[count])
        count += 1

    finalQSet2 = []

    count = 0 
    while count in range(int(len(finalQSet)*0.6)):
        x = {}
        x["Statement"] = finalQSet[count]["trueStmt"][:len(finalQSet[count]["trueStmt"]) - 1]
        x["Answer"] = "True"
        finalQSet2.append(x)
        count = count + 1 

    while count in range(len(finalQSet)):
        x = {}
        x["Statement"] = finalQSet[count]["falseStmt"][:len(finalQSet[count]["falseStmt"]) - 1]
        x["Answer"] = "False"
        finalQSet2.append(x)
        count = count + 1 

    #print("finalQSet2:" + str(finalQSet2))

    finalQuestionsJSON = json.dumps(finalQSet2)

    #print(finalQuestionsJSON)

    # Writing to sample.json
    with open("finalQuestions/sampledQuestions_" + classChoice + "_" + subjectChoice + "_" + chapterChoice + ".json", "w") as outfile:
        outfile.write(finalQuestionsJSON)

    return finalQuestionsJSON
    """
    for i in filteredQs:
      print("--------------------------------")
      print(i["Statement"])
      print(i["difficulty"])
      print(i["difficultyScore"])
      print("--------------------------------")
    """

# you call the function as below
# sampleQuestions('generatedqs_test.json', "Class9", "Geography", "chapter5", 10, 0.3, 0.5, 0.2 )